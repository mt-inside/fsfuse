HIGHLEVEL:
- finish indexnodes & testing
- config should be a class not a static thing. Anything that needs config info
  should take it as an explicit dep.
- fix direntry & listing - getters without get, no setters, proper inheritance
- factor everything that knows about CURL out into its own class
- break fetcher into: metadata_fetcher (which calls nativefs) and block_fetcher
  (singleton actor that can have 1 list per file and have a priq of blocks)
- nativefs actor. metadata requests come to here and it serialises them (no good
  reason really) and uses curl_wrapper and xml_wrapper to get stuff. Can optionally proxy through to a nativefs cache *actor*
- think about logging. trace_info|warn etc should go to the log file too, not
  the console - this is a daemon. the trace stuff should probably be used for operational (non-debugging) stuff. What does unconditional trace do? is it the same thing? Is there a trace_error? Is it the same as assert? (remember no assert on release builds)

 * indexnodes.c do indexnode state machine et al (have internal-only
 *   indexnode_seen (aka reset state) fn.
 * make a fake indexnode (no, just use nc) for the console printer and integration test
 * write a fake indexnode (using node or something) that just mirrors an XML doc
 *   you give it
 * unit test with a fate indexnodes_listener_thread
move logging to methods - each module gets itself a static logger. wtf did we use macros? that way it can't be partially initialised. You know, switchable log file names, etc
move config into its own dir
indexnode state machine and filtering in _get.
pull indexnodes.c apart into listener (that fires event on a packet), manager (actor, hence no locking of the list or anything) (that maintins a list and updates state in response to packets and timer events (has to be proactive on a timer, not lazy on return, becuase many lists have pointer to one refc'd in which needs to be seen to expire to all of them) and maybe others
tell, don't ask: why do indexnode and direntry have getters?
indexnode objects to live forever and just sit in expired causing ENOENT or soemthing when interacted with. expired indexnodes are not put into output list.
write unit test with mock listener
write test frontend that just fires up the indexnode stuff and prints the list of indexnodes and their states every sec
write integration test that fires up indexnodes?

where are indexnodes free()d?
get to the point where each lib (libxml, curl) is refd and understood by only 1 file.
things like indexnodes should be represented as a singleton object so that one delete call can shut down the thread and free everything. Alternately, init and finalise should do that stuff. I don't like the temporal coupling of methods

getters to just be given unmodified names (e.g. user_name), setters to be called set_user_name to mark them out as an exception and code smell
no mutable state yo
jesus, just go throgh this shit and make it better.
Start at the indexnodes thread and indexnode class. Add a listener for all the broadcasts for a particular indexnode after a class has been instantiated for it. Add a state machine for missed pings, active, dead etc
Then start at the front - readdir(). Fetchers should be instantiated over URLs rather than a static thing. de, li to have clear separation, work properly, proper inheritance, etc
Then go for read()

copy config file into ~, look for one in /etc

instead of hand-rolling an http impl, use libevent, which claims to have http support and zero-copy

read and understand http://www.ibm.com/developerworks/linux/library/l-async/ and test every case

Refactoring to improve quality :)
=======
- if a function's first argument is a class *, chances are it should be on that
  class :)
- do the direntry -> listing inheritance properly; de shouldn't habe an in*, its first member should be an li, so that it can be cast to one.
- "Miscellaneous threads should be started from the init() method. Threads
  started before fuse_main() will exit when the process goes into the background."
  - indexnode listener thread, cache actor, etc.
- inodes, lookup, forget, etc. readdir doesn't have to return inode numbers -
  this should allow us to eliminate the inode table thingy. Look for FUSE_UNKNOWN_INO. Indeed, can pass null stat into readdir filler
  - see next_id() in lib/fuse.c
  - this probably isn't true, because one gets multiple lookups for the one
    name; responding to one with an inode doesn't stop you getting more for the same file.
- buffer lifetimes - how long as curl buffers valid? Just for duration of
  callback? How long do buffers passed to fuse_reply_buf need to be valid? If it's just the duration of the call then can just pass curl bufs through as long as we stay on the thread that curl called us from
- go through all mount options in fuse/README
- can chunk_list lock be a rwlock?
- move indexnodes lock to rwlock
- need lifetime support for indexnodes, inc removing ones that don't exist.
  - we could poll them and kick them if they don't reply.
  - or we could wait until a a request to one fails.
  - we should poll them, because when you list / you want an up-to-date response
  - what we should acutally do is have a list_update function, and add states
    DYING[1,2,3] to their machine. If it's missing from the list it gets pushed down a state
    From 3 it disappears from the list (and tell the kernel it's gone thorough clever new mechanism)
- move listing_list_T into its own class
- inode lifecycle (don't keep all inodes forever, dump them when fuse says
  FORGET)
- deal with multiple indexnodes. I suggest a simple parse of the path. Check 1st
  part against indexnode list, ENOENT if not. Then de to gain an indexnode pointer.
  Although the file may exist on many a share, paths are only valid for one indexnode.
- make hash (as in de hash) a 1stclass type(def)
- The cache: start just holding onto listings until the kernel says to forget
  them or that file/dir has stopped existing on the indexnode. This can just be addressed by
  inode and will stop repeated lookups for getattr etc.
  Then elaborate to direntry that knows where it is in the tree and will invalidate parents etc.
- Unit tests
- names for threads (like "getattr for /foo/bar", "read bar 4k-8k") and a collapsed thread id
- make indexnode_listener class. Instantiate one per address to listen on (e.g.
  IP4 all, IP6 all). Thread each? Call a static method to use a master thread?
- statesfor indexnodes - awaiting version, up, missing etc. IsUp() / IsAvailable
  method. This should make static indexnode version finding better (can be async)
- "filesystem abstraction" object to appear. This is direntry_get_by_inode +
  friends. It is to be an active object which queues calls and responds. It makes direct indexnode requests every time. It probably needs to keep a tree for "get child by name" purposes (but look at a tre of paths or something). It is to manage the tree consistency, etc.
- "filesystem abstraction" cache which is also an active object and has the same
  interface as the non-caching one. Do non-expiring first (tree is trimmed when something 404s, but new files never show up). Needs integration tests!. Do auto-expiry next (should be easy). May want to time expire only dirs and not files (i.e. if access an expired file, ignore it, if access out of date dir, do something (cause that's how you miss new stuff)). On expired dir, only re-fecth that dir, not all ancestors. If that dir no longer exists, trigger normal mechanism to purge upwards. "Cached dead actors, stacked to the rafters, line up the bastards, all I want is the truth"
- Direntry and listing to be closely looked at (direntry is a listing in a tree?
  but how does it work when we're not caching?). We need some inheritance / interfaces round here.
- there shouldn't be one downloader thread per path, because then two difference
  accesses will cause massive thrashing. There should be one per (path X "session"). Basically one per open(). open() should stash thread reference or "request #" in fi field.
- support multiple indexnodes. Maybe have a parser/mapper thing like in cdnfs
- Make proper temporal use of the vfs contract. I.e. open() should start a
  download steam with an empty block list. A handle to this should be stashed in our private context field. read() shouldn't need to start that off, or check whether the file exists, because it knows certain things about open() and what it's done.
- add const annotations (and * const) ... everywhere!
- cache to tell kernel when a file has been "deleted". There was a fuselib git
  path on 6th dec 2011 which allows this
- There should be a very clear indication as to which calls could block so that
  you can pass them continuations. Of course whether they blocks depends on whether they've been called recently.
  For read() it makes perfect sense to pass a continuation and return because we use a thread pool for downloading.
  However getattr is one/one threads - eg you may as well had wait for your getattr call.
- sort out headers: common.h first, module headers, sys headers, fsfuse headers
  in alpha order. Minimal header sets always.


**WARNING** THIS IS NOT UNDER VERSION CONTROL.
- resurect the wiki :)

Switch to low-level interface
make use of dprintf

Test inode behaviour wiht early branch or small test high-level fs. (use ls -i / df -i). See what allocation scheme is, how numbers tiw with lookup / forget / etc.
Play with inodes in low-level sandbox.

System tests!
- Various read() patterns.
- Various readdir() patterns (straight in at the bottom, etc)
- Mock indexnode that goes away at *all* stages of all fetches

split dtp into downloader_thread and a pool
- except, pool currently just spwans ad infinitum, but still have callers go
  through it
- thread wil need ::reset() to clear all state and let it go back in the pool
- creating threads isn't expensive, we're just worried about DoSing, so thread
  pool doesn't need a pool, just a max count.
reduce memcpy()s - either point libcurl into fuse's buffers, or more likely hold lubcurl's buffers around and make an iovec response to read().
Factor indexnode hackery into an object as the first step to supporting multiple indexnodes.
This then allows securemode, with some thinking.
proper handling of remote queueing / async io etc
Change the cache to be an instance of the composite pattern - same interface as the fetcher, and conditionally compiled. Prob use a vtable.
Change the whole direntry system /cache to be an active object. This means you just message-pass to some instance of the direntry interface, be it cache or not. This should also eliminate all the bloody locking problems.
